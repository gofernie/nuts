---
// File: src/pages/xtraarea/[slug].astro
import Site from "../../layouts/Site.astro";
import { getJson } from "../../lib/fetchJson";
import { heroPath } from "../../lib/paths";

export async function getStaticPaths() {
  const url = import.meta.env.PUBLIC_XTRAAREA_JSON;
  if (!url) return [];

  let rows:any[] = [];
  try {
    const raw = await getJson<any>(url);
    rows =
      Array.isArray(raw) ? raw :
      Array.isArray(raw?.data) ? raw.data :
      Array.isArray(raw?.rows) ? raw.rows : [];
  } catch {
    return [];
  }

  const items = rows.map((r:any) => {
    const get=(k:string)=>(r?.[k] ?? r?.[k?.toLowerCase?.()] ?? r?.[k?.toUpperCase?.()] ?? "").toString().trim();
    const title = get("title"); if (!title) return null;

    const computedSlug = title.toLowerCase()
      .replace(/&/g,"-and-")
      .replace(/[^a-z0-9]+/g,"-")
      .replace(/^-+|-+$/g,"");

    return {
      slug: get("slug") || computedSlug,
      title,
      summary: get("summary"),
      hero_img: get("hero_img"),
      map_embed: get("map_embed"),
      long_copy: get("long_copy"),
      cta1: get("cta1"),
      status: get("status"),
      seo_title: get("seo_title"),
      seo_description: get("seo_description"),
      spare_1: get("spare_1"),
    };
  }).filter((r)=> r && r.slug && r.title && r.slug.toLowerCase()!=="index" && !/^draft$/i.test(r.status||""));

  return items.map((n:any)=>({
    params:{ slug:n.slug },
    props:{
      title: n.title,
      summary: n.summary || "",
      hero: heroPath(n.hero_img),
      cta1: n.cta1 || "",
      map_embed: (() => {
        const v = (n.map_embed || "").trim();
        if (!v) return "";
        const m = v.match(/src="([^"]+)"/i);
        if (m?.[1]) return m[1];
        if (v.includes("google.com/maps") && v.includes("embed")) return v;
        if (v.includes("google.com/maps")) {
          try {
            const u = new URL(v);
            const q = u.search ? `${u.search}&output=embed` : "?output=embed";
            return `https://www.google.com/maps${q}`;
          } catch {}
        }
        return `https://www.google.com/maps?q=${encodeURIComponent(v)}&output=embed`;
      })(),
      long_copy: n.long_copy || "",
      seo_title: n.seo_title || "",
      seo_description: n.seo_description || "",
      spare_1: n.spare_1 || "",
    }
  }));
}

const {
  title, summary, hero, map_embed, long_copy, cta1, spare_1,
  seo_title, seo_description
} = Astro.props as any;

const pageSeoTitle = seo_title || title || "Area";
const pageSeoDesc  = seo_description || summary || "";

const isUrl = (v:string) => /^https?:\/\//i.test(v || "");
---

<Site
  showHeader={true}
  title={title}
  seo_title={pageSeoTitle}
  seo_description={pageSeoDesc}
>

  {hero && (
    <Fragment slot="head">
      <link rel="preload" as="image" href={hero} fetchpriority="high" />
    </Fragment>
  )}

  <!-- Hero -->
  <section class="hero-bleed">
    {hero && (
      <img
        src={hero}
        alt=""
        fetchpriority="high"
        loading="eager"
        decoding="async"
        width="2000" height="1000"
      />
    )}
  </section>

  <div class="container intro">
    <h1>{title}</h1>
    {summary && <p>{summary}</p>}
  </div>

  <!-- Listings embed (LAZY LOADED) -->
  {spare_1 && (
    <div class="container embed-wrap">
      <div id="mrp-container" class="mrp-container" aria-live="polite">
        <!-- Skeleton to hold space & avoid CLS -->
        <div id="mrp-skeleton" class="mrp-skeleton" aria-hidden="true">
          <div class="sk-row"></div>
          <div class="sk-row"></div>
          <div class="sk-row"></div>
        </div>

        <!-- We stash the embed as data; JS will inject when near viewport -->
        {isUrl(spare_1)
          ? <div id="mrp-embed-src" data-src={spare_1}></div>
          : <template id="mrp-embed-html" data-type="html">{spare_1}</template>
        }
      </div>
    </div>
  )}

  {map_embed && (
    <div class="container map-wrap">
      <h2>Explore on the Map</h2>
      <div class="map-card">
        <iframe
          src={map_embed}
          title={`Map of ${title}`}
          loading="lazy"
          allowfullscreen
          referrerpolicy="no-referrer-when-downgrade"
          style="width:100%; height: min(720px, var(--hero-h)); border:0; display:block;"
        ></iframe>
      </div>
    </div>
  )}

  {cta1 && (
    <div class="container">
      <div class="cta-card">
        <h2>Ready to explore {title} listings?</h2>
        <p>Browse every property and get instant alerts for price changes.</p>
        <a href={cta1} class="cta-btn"><span class="cta-text">ðŸ”Ž View Listings</span></a>
      </div>
    </div>
  )}

  {long_copy && (
    <div class="container">
      <article class="long-copy" set:html={long_copy}></article>
    </div>
  )}

  <!-- Page styles -->
  <style>
    .intro { margin: 24px auto 20px; }
    .intro h1 { font-size: 2.25rem; font-weight: 700; margin: 0 0 8px; color:#111827; }
    .intro p { font-size: 1rem; line-height:1.6; color:#1f2937; }

    /* Listings embed container â€” force WHITE background and show it around cards */
    .embed-wrap {
      margin: 32px auto;
      background: #fff !important;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
    }
    .mrp-container {
      max-width: var(--content-max, 1100px);
      margin: 0 auto;
      overflow: visible;
      background: transparent !important;
    }

    /* Skeleton (approximate card heights; light for perf) */
    .mrp-skeleton { display: grid; gap: 16px; }
    .mrp-skeleton .sk-row {
      height: 220px;              /* mobile-friendly placeholder */
      border-radius: 12px;
      background:
        linear-gradient(90deg, rgba(0,0,0,.06), rgba(0,0,0,.10), rgba(0,0,0,.06));
      background-size: 200% 100%;
      animation: sk 1.2s ease-in-out infinite;
    }
    @media (min-width: 769px) {
      .mrp-skeleton .sk-row { height: 260px; }
    }
    @keyframes sk {
      0% { background-position: 0% 0; }
      100% { background-position: -200% 0; }
    }

    .mrp-container iframe {
      width: 100% !important;
      display: block;
    }

    /* Map card */
    .map-wrap h2{ font-size:1.25rem; margin:8px 0 12px; color:#111827; }
    .map-card{ border:1px solid #eee; border-radius:12px; overflow:hidden; box-shadow:0 1px 6px rgba(0,0,0,0.1); }

    /* CTA */
    .cta-card{ background:#fff; color:#111827; border:2px solid #e5e7eb; border-radius:16px; padding:28px 20px; margin:36px 0; text-align:center; box-shadow:0 6px 18px rgba(0,0,0,0.08); }
    .cta-card h2{ margin:0 0 10px; font-size:1.75rem; font-weight:700; }
    .cta-card p{ font-size:1rem; color:#374151; margin-bottom:18px; }
    .cta-btn{ display:inline-flex; align-items:center; justify-content:center; gap:8px; background:#0a7bff; color:#fff; text-decoration:none; font-weight:700; font-size:1.125rem; padding:12px 28px; border-radius:999px; box-shadow:0 4px 10px rgba(0,0,0,0.15); transition: background .15s ease, box-shadow .15s ease; }
    .cta-btn .cta-text{ text-decoration:none; }
    .cta-btn:hover{ background:#065aa3; box-shadow:0 6px 14px rgba(0,0,0,0.25); }

    .long-copy{ margin:40px 0 48px; font-size:1.05rem; line-height:1.8; color:#1f2937; }
    .long-copy p{ margin:0 0 1.25em; }
    .long-copy h2,.long-copy h3{ font-weight:700; color:#111827; line-height:1.3; margin:2em 0 .75em; }
    .long-copy h2{ font-size:1.5rem; border-left:4px solid #0a7bff; padding-left:.5rem; }
    .long-copy h3{ font-size:1.25rem; }
  </style>

  <!-- Global: force inner backgrounds white & mobile 1-col -->
  <style is:global>
    /* Make inner MRP wrappers white too (some themes set their own bg) */
    .embed-wrap .listing-results-view,
    .embed-wrap .resultsContainer,
    .embed-wrap .results,
    .embed-wrap .searchResults,
    .embed-wrap .mrp-grid,
    .embed-wrap .result-grid,
    .embed-wrap .mrp-listing-result,
    .embed-wrap .mrp-listing,
    .embed-wrap .result,
    .embed-wrap .result-item,
    .embed-wrap .srItem,
    .embed-wrap .searchResultItem {
      background-color: #fff !important;
    }

    /* Mobile: force ONE full-width card per row */
    @media (max-width: 768px) {
      .listing-results-view,
      .results,
      .resultsContainer,
      .searchResults,
      .mrp-grid,
      .result-grid {
        display: block !important;
        grid-template-columns: 1fr !important;
        column-gap: 0 !important;
        row-gap: 0 !important;
      }
      .mrp-listing-result,
      .mrp-listing,
      .result,
      .result-item,
      .srItem,
      .searchResultItem,
      .listing-results-view > div,
      .results > div,
      .resultsContainer > div {
        width: 100% !important;
        max-width: 100% !important;
        float: none !important;
        clear: both !important;
        display: block !important;
        margin: 0 0 16px !important;
        box-sizing: border-box !important;
      }
      .mrp-listing .photo,
      .mrp-listing .details,
      .mrp-listing-result .photo,
      .mrp-listing-result .details,
      .result .photo,
      .result .details {
        width: 100% !important;
        float: none !important;
        display: block !important;
      }
      .mrp-listing img,
      .mrp-listing-result img,
      .result img,
      .srItem img,
      .searchResultItem img {
        width: 100% !important;
        max-width: 100% !important;
        height: auto !important;
        display: block !important;
      }
    }

    /* Desktop: keep your 3-up (if MRP uses this) */
    .mrp-listing-result { width: 33.333% !important; max-height: 490px; }
  </style>

  <!-- LAZY LOADER -->
  <script>
    (function(){
      const container = document.getElementById('mrp-container');
      if (!container) return;

      const skeleton = document.getElementById('mrp-skeleton');
      const srcHolder = document.getElementById('mrp-embed-src');
      const htmlTpl   = document.getElementById('mrp-embed-html');

      let loaded = false;

      function removeSkeletonWhenReady() {
        // If script injects content after load, watch for first child nodes
        const done = () => skeleton && skeleton.parentNode && skeleton.parentNode.removeChild(skeleton);
        if (!skeleton) return;

        // If content already there, remove now
        if (container && container.children.length > 0 && container.children[0] !== skeleton) {
          done(); return;
        }

        const obs = new MutationObserver(() => {
          if (container && container.querySelector(':not(#mrp-skeleton)')) {
            obs.disconnect(); done();
          }
        });
        obs.observe(container, { childList: true, subtree: true });

        // Safety timeout to avoid hanging skeletons
        setTimeout(() => { try { obs.disconnect(); } catch(e){} done(); }, 8000);
      }

      function injectEmbed() {
        if (loaded) return;
        loaded = true;

        // URL embed -> create script tag now
        if (srcHolder && srcHolder.dataset && srcHolder.dataset.src) {
          const url = srcHolder.dataset.src;
          const s = document.createElement('script');
          s.id = 'mrpscript';
          s.src = url;  // keep your original URL (MRP handles its own async)
          s.async = true;

          // Remove skeleton on load (best-effort; some widgets render after load)
          s.addEventListener('load', removeSkeletonWhenReady);
          s.addEventListener('error', removeSkeletonWhenReady);

          container.appendChild(s);
          removeSkeletonWhenReady();
          return;
        }

        // Raw HTML embed -> materialize from template
        if (htmlTpl && htmlTpl.content) {
          container.appendChild(htmlTpl.content.cloneNode(true));
          removeSkeletonWhenReady();
          return;
        }

        // Nothing to inject; remove skeleton anyway
        removeSkeletonWhenReady();
      }

      // Lazy: when near viewport
      const io = ('IntersectionObserver' in window)
        ? new IntersectionObserver((entries) => {
            entries.forEach((e) => {
              if (e.isIntersecting) {
                io.disconnect();
                injectEmbed();
              }
            });
          }, { root: null, rootMargin: '800px 0px', threshold: 0.01 }) // start early for mobile
        : null;

      if (io) {
        io.observe(container);
      } else {
        // Fallback: inject after first user interaction or small delay
        let fired = false;
        const fire = () => { if (!fired) { fired = true; injectEmbed(); } };
        window.addEventListener('scroll', fire, { once: true, passive: true });
        window.addEventListener('touchstart', fire, { once: true, passive: true });
        window.addEventListener('mousemove', fire, { once: true });
        setTimeout(fire, 2500);
      }

      // Also inject on very slow pages after a longer delay (belt & suspenders)
      setTimeout(() => { if (!loaded) injectEmbed(); }, 10000);
    })();
  </script>
</Site>
