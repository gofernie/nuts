---
type Btn = { label: string; href: string; test?: string };

interface Props {
  items?: Btn[];
  raw?: string;
  anchor?: string;   // e.g. "#filters" (default)
  sticky?: boolean;  // set true to make the bar sticky
  class?: string;    // extra classes for <nav>
}

const {
  items = [],
  raw = "",
  anchor = "#filters",
  sticky = false,
  class: extraClass = "",
} = Astro.props as Props;

const norm = (s:string) => (s || "").trim();
const isHttp = (u:string)=> /^https?:\/\//i.test(u);
const isSpecial = (u:string)=> u.startsWith("mailto:") || u.startsWith("tel:");
const sameOrigin = (u:string)=> !isHttp(u) && !isSpecial(u);

function titleFromHref(href:string){
  const seg = (href || "/").replace(/\/+$/,"").split("/").pop() || href;
  const words = seg.replace(/[-_]+/g," ").replace(/[^a-z0-9 ]/gi," ").trim();
  const nice = words.replace(/\s+/g," ").toLowerCase().replace(/\b\w/g, c => c.toUpperCase());
  return nice || "View Listings";
}

function parseRaw(rawStr = ""): Btn[] {
  const s = norm(rawStr);
  if (!s) return [];
  const parts = s.split(/,|\n/).map(norm).filter(Boolean);
  const out: Btn[] = [];
  for (const part of parts) {
    if (part.includes("|")) {
      const [labelRaw, hrefRaw, testRaw] = part.split("|").map(norm);
      const href = hrefRaw || "";
      const label = labelRaw || titleFromHref(href);
      if (href) out.push({ label, href, test: testRaw || undefined });
    } else {
      const href = norm(part);
      if (href) out.push({ label: titleFromHref(href), href });
    }
  }
  // de-dupe by href
  const seen = new Set<string>();
  return out.filter(b => {
    const key = b.href.toLowerCase();
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}

const fromRaw = parseRaw(raw);
const list: Btn[] = (items.length ? items : fromRaw).filter(b => norm(b.href));

const cur = Astro.url.pathname.replace(/\/+$/, "") || "/";
const isActive = (href: string, test?: string) => {
  const h = (href || "").replace(/\/+$/, "") || "/";
  if (test) { try { return new RegExp(test).test(cur); } catch {} }
  if (isHttp(h) || isSpecial(h)) return false;
  return cur === h;
};

if (list.length === 0) Astro.self.close();
---
<nav
  class={`listing-buttons ${sticky ? "is-sticky" : ""} ${extraClass}`.trim()}
  aria-label="Listing filters"
>
  {list.map(({ label, href, test }) => {
    const active = isActive(href, test);

    // Append anchor to internal links if there isn't already a hash
    const finalHref =
      (sameOrigin(href) && anchor && !href.includes("#"))
        ? `${href}${anchor}`
        : href;

    // External links can optionally open new tab; keeping same-tab here
    const isExternal = isHttp(href);

    return (
      <a
        class={`btn-link${active ? " is-active" : ""}`}
        href={finalHref}
        aria-current={active ? "page" : undefined}
        rel={isExternal ? "noopener" : undefined}
      >
        {label}
      </a>
    );
  })}
</nav>

<style>
  /* Active state â€“ uses your palette */
  .btn-link.is-active {
    background: var(--color-primary-bg, #111);
    color: var(--color-on-primary, #fff);
    border-color: var(--color-primary-border, #111);
    font-weight: 600;
  }

  /* Optional sticky behavior */
  .listing-buttons.is-sticky {
    position: sticky;
    top: var(--anchor-offset, 0); /* set to header height if you add a sticky header */
    background: var(--color-page, #fff);
    padding-block: 0.25rem;
    z-index: 10;
  }
</style>
